version: 2.1

description: Builds a Haskell application using cabal v2-*.

executors:
  ghc-7_10_3:
    docker:
      - image: quay.io/haskell_works/ghc-7.10.3:latest
  ghc-8_0_2:
    docker:
      - image: quay.io/haskell_works/ghc-8.0.2:latest
  ghc-8_2_2:
    docker:
      - image: quay.io/haskell_works/ghc-8.2.2:latest
  ghc-8_4_4:
    docker:
      - image: quay.io/haskell_works/ghc-8.4.4:latest
  ghc-8_4_3:
    docker:
      - image: quay.io/haskell_works/ghc-8.4.3:latest
  ghc-8_6_3:
    docker:
      - image: quay.io/haskell_works/ghc-8.6.3:latest
  ghc-844:
    docker:
      - image: quay.io/haskell_works/ghc-8.4.4:latest
  ghc-863:
    docker:
      - image: quay.io/haskell_works/ghc-8.6.3:latest

commands:
  override-ghc:
    steps:
      - run:
          name: Override GHC version
          command: |
            test -f cabal.project || echo 'packages: .' > cabal.project
            test -f cabal.project.freeze || touch cabal.project.freeze
            _ghc_ver=$(ghc --numeric-version)
            sed -i '/^with-compiler:/{h;s/:.*/: ghc-'"$_ghc_ver"'/};${x;/^$/{s//with-compiler: ghc-'"$_ghc_ver"'/;H};x}' cabal.project

  set-project-env:
    parameters:
      cache-version:
        description: Cache version. Update this value when you want to start with new build caches.
        type: string
      cabal-file:
        description: Optional .cabal file. If none provided, first found will be used.
        type: string
        default: ""
    steps:
      - when:
          condition: << parameters.cabal-file >>
          steps:
            - run:
                name: "Validating provided cabal file"
                command: |
                  if [ ! -f "<< parameters.cabal-file >>" ]; then
                    echo "Cabal file was specified, but doesn't exist << parameters.cabal-file >>"
                    exit 1
                  fi
                  BUILD_CABAL_FILE=<< parameters.cabal-file >>
                  echo "export BUILD_CABAL_FILE=$BUILD_CABAL_FILE" >> $BASH_ENV
                  source $BASH_ENV
      - unless:
          condition: << parameters.cabal-file >>
          steps:
            - run:
                name: Searching for Cabal file to build
                command: |
                  if [ -f cabal.project ]; do -----
                  BUILD_CABAL_FILE=$((ls ${CIRCLE_PROJECT_REPONAME}.cabal || ls *.cabal) | head -n 1)
                  ## What to do with multiple cabal packages?
                  # BUILD_CABAL_FILE=$((ls ${CIRCLE_PROJECT_REPONAME}.cabal || ls *.cabal || find . -type f -name '*.cabal') | head -n 1)
                  if [ "$BUILD_CABAL_FILE" = "" ]; then
                    echo "Could not find .cabal file"
                    exit 1
                  fi
                  echo "Found $BUILD_CABAL_FILE, using it"
                  echo "export BUILD_CABAL_FILE=$BUILD_CABAL_FILE" >> $BASH_ENV
                  source $BASH_ENV

      - when:
          name: Checking if hackage would accept cabal file
          condition: << parameters.run-check >>
          steps:
            - run:
                name: Running cabal check (can be disabled in CI with run-check=false)
                command: |
                  for x in $(cat cabal.project | sed -n '/^packages:/,/^$/ p' | sed 's|^packages:||g'); do
                    ( echo "\n# Running cabal check in $x"
                      cd "$x"
                      cabal check
                    )
                  done

      - run:
          name: Setting project environment
          command: |
            mkdir -p ./build

            find . -name "*.cabal" | grep -v 'dist-newstyle/' | sort | xargs grep '^' | grep -v ':version:' | md5sum > ./build/project.summary

            BUILD_DIST="./dist-newstyle/build"
            BUILD_CABAL_VERSION=$(cabal --numeric-version)
            BUILD_GHC_VERSION=$(cat cabal.project | grep 'with-compiler:' | head -n 1 | tr -s ' ' | cut -d' ' -f2 | cut -d'-' -f2)
            if [ "$BUILD_GHC_VERSION" = "" ]; then BUILD_GHC_VERSION=$(ghc -- --numeric-version); fi
            BUILD_PROJECT_NAME=$(cat "$BUILD_CABAL_FILE" | grep '^name:' | head -n 1 | cut -d':' -f 2 | xargs)
            BUILD_PROJECT_VERSION=$(cat "$BUILD_CABAL_FILE" | grep -e "^version" | head -n 1 | tr -s " " | cut -d' ' -f2)
            BUILD_EXE_NAMES=$(cat "$BUILD_CABAL_FILE" | grep 'executable ' | head -n 1 | tr -s ' ' | cut -d' ' -f2 || echo '')
            BUILD_ARCH=$(uname -m)
            BUILD_OS_NAME=$(uname -s | tr '[:upper:]' '[:lower:]')
            BUILD_OS_SUFFIX=$BUILD_OS_NAME
            if [ "$BUILD_OS_SUFFIX" = "darwin" ]; then BUILD_OS_SUFFIX="osx"; fi

            echo "$BUILD_GHC_VERSION" > ./build/ghc.version

            echo "CACHE_VERSION=<< parameters.cache-version >>"         > ./build/build.env
            echo "BUILD_GHC_VERSION=$BUILD_GHC_VERSION"                >> ./build/build.env
            echo "BUILD_ARCH=$BUILD_ARCH"                              >> ./build/build.env
            echo "BUILD_OS_NAME=$BUILD_OS_NAME"                        >> ./build/build.env

            echo "export BUILD_CABAL_VERSION=$BUILD_CABAL_VERSION"      > ./build/project.env
            echo "export BUILD_GHC_VERSION=$BUILD_GHC_VERSION"         >> ./build/project.env
            echo "export BUILD_ARCH=$BUILD_ARCH"                       >> ./build/project.env
            echo "export BUILD_OS_NAME=$BUILD_OS_NAME"                 >> ./build/project.env
            echo "export BUILD_OS_SUFFIX=$BUILD_OS_SUFFIX"             >> ./build/project.env
            echo "export BUILD_CABAL_FILE=$BUILD_CABAL_FILE"           >> ./build/project.env
            echo "export BUILD_PROJECT_NAME=$BUILD_PROJECT_NAME"       >> ./build/project.env
            echo "export BUILD_PROJECT_VERSION=$BUILD_PROJECT_VERSION" >> ./build/project.env
            echo "export BUILD_EXE_NAMES=(${BUILD_EXE_NAMES[*]})"      >> ./build/project.env
            echo "export BUILD_EXE_NAME=${BUILD_EXE_NAMES[0]}"         >> ./build/project.env

            cat ./build/project.env >> $BASH_ENV
            cat ./build/project.env
            source $BASH_ENV

  copy-bin:
    steps:
      - run:
          name: Copying executable
          command: |
            mkdir -p ./build/dist
            _os_suffix=$OS_NAME
            if [ "$_os_suffix" = "darwin" ]; then _os_suffix="osx"; fi
            # according to Cabal docs executables are located here
            _exe_build_path="$PWD/dist-newstyle/build/$BUILD_ARCH-$BUILD_OS_NAME/ghc-$BUILD_GHC_VERSION/$BUILD_PROJECT_NAME-$BUILD_PROJECT_VERSION/x/"
            # copy all the executables
            find "$_exe_build_path" -type f -perm -a=x -regextype egrep -regex '^.+/x/(.+)/build/\1/\1$' -exec cp -- "{}" "$PWD/build/dist" \;
            ls --recursive ./build

  check-immediate-dependencies-coherence:
    description: Check if --enable-test and --enable-benchmark are safe to use
    steps:
      - run:
          name: Check immediate dependencies coherence
          command: |
            cp cabal.project enable.cabal.project
            cp cabal.project disable.cabal.project
            cabal new-freeze --project-file enable.cabal.project --enable-tests --enable-benchmarks
            cabal new-freeze --project-file disable.cabal.project --disable-tests --disable-benchmarks
            (diff disable.cabal.project.freeze enable.cabal.project.freeze || true) \
              | (grep "<" || true)                                                  \
              | (grep -v 'constraints:' || true)                                    \
              | tr -s ' '                                                           \
              | cut -d ' ' -f 2                                                     \
              | cut -d '.' -f 2 > build/changing-dependencies.txt
            cabal-plan info | sed -n '/^CompNameLib$/,/^$/ p'                       \
              | (grep '  ' || true)                                                 \
              | sed 's|^  ||g'                                                      \
              | rev                                                                 \
              | cut -d '-' -f 2-                                                    \
              | rev > build/immediate-dependencies.txt
            touch .circleci/whitelist-dependencies.txt
            comm -13 .circleci/whitelist-dependencies.txt build/immediate-dependencies.txt > build/important-dependencies.txt
            comm -12 build/changing-dependencies.txt build/important-dependencies.txt > build/incoherent-dependencies.txt

            echo "Changing dependencies: "
            sed 's|^|  |g' build/changing-dependencies.txt
            echo "Whitelisted dependencies: "
            sed 's|^|  |g' .circleci/whitelist-dependencies.txt
            echo "Incoherent dependencies: "
            sed 's|^|  |g' build/incoherent-dependencies.txt

            if [ "$(cat build/incoherent-dependencies.txt | xargs)" != "" ]; then
              echo "Error: Found incoherent immediate dependencies"
              exit 1
            fi
            echo "export _BUILD_ENABLE_TESTS_FLAG=--enable-tests" >> $BASH_ENV
            echo "export _BUILD_ENABLE_BENCHMARKS_FLAG=--enable-benchmarks" >> $BASH_ENV
            source $BASH_ENV

jobs:
  build:
    parameters:
      executor:
        description: |
          An executor that contains GHC and cabal-install (supporting v2-* commands family.)
          "ghc-8_4_4" and "ghc-8_6_3" are provided, but custom executors can be used (see examples).
        type: executor
        default: ghc-8_4_4
      cache-version:
        description: Cache version. Update this value when you want to start with new build caches.
        type: string
        default: ${CACHE_VERSION:-cache-01}
      cabal-threads:
        description: Number of Cabal threads.
        type: integer
        default: 4
      cabal-file:
        description: Cabal file name (including the .cabal extension)
        type: string
        default: ""
      fail-incoherent-builds:
        description: Fail the build when immediate dependencies are incoherent
        type: boolean
        default: true
      run-tests:
        description: Boolean for whether or not to run unit tests
        type: boolean
        default: true
      run-check:
        description: Boolean for whether or not to check if the package has valid cabal file for distribution
        type: boolean
        default: true
      write-result-workspace:
        description: Boolean for whether or not to persist results to a workspace.
        type: boolean
        default: false
      after-checkout:
        description: Optional steps to run after checkout
        type: steps
        default: []
      before-build:
        description: Optional steps to run after cabal update but before build
        type: steps
        default: []
      after-build:
        description: Optional steps to run after build but before running tests
        type: steps
        default: []
      after-test:
        description: Optional steps to run after executing unit tests
        type: steps
        default: []

    executor: << parameters.executor >>
    steps:
      - checkout
      - run: git fetch --unshallow || true

      - when:
          name: Running after-checkout hook steps
          condition: << parameters.after-checkout >>
          steps: << parameters.after-checkout >>

      - override-ghc
      - set-project-env:
          cache-version: << parameters.cache-version >>

      - restore_cache:
          keys:
            - dot-cabal-{{ checksum "./build/build.env" }}-{{ checksum "cabal.project" }}-{{ checksum "cabal.project.freeze" }}-{{ checksum "./build/project.summary" }}
            - dot-cabal-{{ checksum "./build/build.env" }}-{{ checksum "cabal.project" }}-{{ checksum "cabal.project.freeze" }}
            - dot-cabal-{{ checksum "./build/build.env" }}

      - restore_cache:
          keys:
            - dist-{{ checksum "./build/build.env" }}-{{ checksum "cabal.project" }}-{{ checksum "cabal.project.freeze" }}-{{ checksum "./build/project.summary" }}
            - dist-{{ checksum "./build/build.env" }}-{{ checksum "cabal.project" }}

      - run: cabal v2-update -j<< parameters.cabal-threads >>

      - when:
          name: Running before-build hook steps
          condition: << parameters.before-build >>
          steps: << parameters.before-build >>

      - when:
          name: Check immediate dependencies coherence
          condition: << parameters.fail-incoherent-builds >>
          steps:
            - check-immediate-dependencies-coherence

      - run: cabal v2-build $_BUILD_ENABLE_TESTS_FLAG $_BUILD_ENABLE_BENCHMARKS_FLAG --dependencies-only -j<< parameters.cabal-threads >>

      - save_cache:
          key: dot-cabal-{{ checksum "./build/build.env" }}-{{ checksum "cabal.project" }}-{{ checksum "cabal.project.freeze" }}
          paths: [~/.cabal/packages, ~/.cabal/store]

      - save_cache:
          key: dot-cabal-{{ checksum "./build/build.env" }}
          paths: [~/.cabal/packages, ~/.cabal/store]

      - run:
          name: Building project
          command: cabal v2-build $_BUILD_ENABLE_TESTS_FLAG $_BUILD_ENABLE_BENCHMARKS_FLAG -j<< parameters.cabal-threads >>

      - when:
          name: Running after-build hook steps
          condition: << parameters.after-build >>
          steps: << parameters.after-build >>

      - when:
          condition: << parameters.run-tests >>
          steps:
            - run:
                name: Running unit tests
                command: cabal v2-test $_BUILD_ENABLE_TESTS_FLAG $_BUILD_ENABLE_BENCHMARKS_FLAG -j<< parameters.cabal-threads >>

      - when:
          name: Running after-test hook steps
          condition: << parameters.after-test >>
          steps: << parameters.after-test >>

      - save_cache:
          key: dist-{{ checksum "./build/build.env" }}-{{ checksum "cabal.project" }}
          paths: [./dist-newstyle]

      - save_cache:
          key: dist-{{ checksum "./build/build.env" }}-{{ checksum "cabal.project" }}-{{ checksum "cabal.project.freeze" }}-{{ checksum "./build/project.summary" }}
          paths: [./dist-newstyle]

      - save_cache:
          key: dot-cabal-{{ checksum "./build/build.env" }}-{{ checksum "cabal.project" }}-{{ checksum "cabal.project.freeze" }}-{{ checksum "./build/project.summary" }}
          paths: [~/.cabal/packages, ~/.cabal/store]

      - when:
          condition: << parameters.write-result-workspace >>
          steps:
            - copy-bin
            - persist_to_workspace:
                root: .
                paths: [build]

examples:
  build-application:
    description: |
      A typical workflow for building Haskell applications.
      It uses the default executor (GHC 8.4.4) to build an app.
    usage:
      version: 2.1

      orbs:
        haskell: haskell-works/haskell-build@1.0.1

      workflows:
        build-my-application:
          jobs:
            - haskell/build

  build-library:
    description: |
      Building a library often requires building and testing it with multiple versions of GHC.
      It also does not require producing binaries, so in this example we disable writing a workspace.

    usage:
      version: 2.1

      orbs:
        haskell: haskell-works/haskell-build@1.0.0 # use latest version

      workflows:
        build-my-library:
          jobs:
            - haskell/build:
                name: GHC 8.4.4
                executor: haskell/ghc-8_4_4

            - haskell/build:
                name: GHC 8.6.3
                executor: haskell/ghc-8_6_3

  life-cycle-hooks:
    description: |
      Use custom lifecycle hooks to add project-specific steps to a build process

    usage:
      version: 2.1

      orbs:
        haskell: haskell-works/haskell-build@1.0.0 # use latest version

      workflows:
        build-my-application:
          jobs:
            - haskell/build:
                cabal-file: my-application.cabal
                before-build:
                  - run: echo "I run before build"
                after-build:
                  - run: echo "I run after build"
                after-test:
                  - run: echo "I run after tests"
